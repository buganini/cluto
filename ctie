#!/usr/bin/env python
"""
 Copyright (c) 2012 Kuan-Chung Chiu <buganini@gmail.com>

 Permission to use, copy, modify, and distribute this software for any
 purpose with or without fee is hereby granted, provided that the above
 copyright notice and this permission notice appear in all copies.

 THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 WHATSOEVER RESULTING FROM LOSS OF MIND, USE, DATA OR PROFITS, WHETHER
 IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
 OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

"""

import os
import sys
import tempfile
from gi.repository import Gtk, Gdk, cairo, GObject
import md5
import Image
import re
import weakref
import pickle

def try_int(s):
	try: return int(s)
	except: return s

def natsort_key(s):
	return map(try_int, re.findall(r'(\d+|\D+)', s))

def natcmp(a, b):
	return cmp(natsort_key(a), natsort_key(b))

tempdir=None
id_map={}
cache_gtk={}
cache_pil_rgb={}
cache_pil_l={}
clear_tempdir=True

def click(o):
	evt=Gdk.Event(Gdk.EventType.BUTTON_PRESS)
	evt.button.type=Gdk.EventType.BUTTON_PRESS
	evt.button.button=1
	o.emit("button-press-event", evt)


class Item(object):
	def __init__(self, p):
		self.p=p
		self.hash=id_map[p['path']]

	def get_gtk(self):
		global cache_gtk
		oid=id(self.p)
		try:
			o=cache_gtk[oid]()
#			o=cache_gtk[oid]
		except:
			o=None
		if not o:
			o=Gtk.Image.new_from_file(self.get_cropped())
			cache_gtk[oid]=weakref.ref(o)
#			cache_gtk[oid]=o
		return o

	def get_pil_rgb(self):
		global cache_pil_rgb
		oid=id(self.p)
		try:
			o=cache_pil_rgb[oid]()
		except:
			o=None
		if not o:
			o=Image.open(self.p['path']).convert('RGB')
			cache_pil_rgb[oid]=weakref.ref(o)
		return o

	def get_pil_l(self):
		global cache_pil_l
		oid=id(self.p)
		try:
			o=cache_pil_l[oid]()
		except:
			o=None
		if not o:
			o=Image.open(self.p['path']).convert('L')
			cache_pil_l[oid]=weakref.ref(o)
		return o

	def get_tempdir(self):
		global tempdir
		if not tempdir or not os.path.exists(tempdir):
			tempdir=tempfile.mkdtemp(prefix='ctie_')
		return tempdir

	def get_cropped(self):
		bfile=os.path.join(self.get_tempdir(), "%s-%dx%dx%dx%d.jpg" % (self.hash, self.p['x1'], self.p['y1'], self.p['x2'], self.p['y2']))
		if not os.path.exists(bfile):
			im=self.get_pil_rgb().crop((self.p['x1'], self.p['y1'], self.p['x2'], self.p['y2']))
			im.save(bfile)	
			del(im)	
		return bfile

	def get_thumbnail(self):
		tfile=os.path.join(self.get_tempdir(), "%s-%dx%dx%dx%d-thumbnail.jpg" % (self.hash, self.p['x1'], self.p['y1'], self.p['x2'], self.p['y2']))
		if not os.path.exists(tfile):
			im=Image.open(self.get_cropped())
			ow,oh=im.size
			nw,nh=(160,240)
			if float(ow)/oh>float(nw)/nh:
				newsize=(nw, int(float(nw)*oh/ow))
			else:
				newsize=(int(float(nh)*ow/oh), nh)
			if newsize[0]<im.size[0] and newsize[1]<im.size[1]:
				im.thumbnail(newsize)
			else:
				im=im.resize(newsize)
			im.save(tfile)
			del(im)
		return tfile

class CTIE(object):
	def __init__(self):
		self.focus_field=(None, None)
		self.focus_entry=None
		self.clipboard=[]
		self.selections=[]
		self.curr_level=None
		self.last_level=None
		self.current_image=None
		self.focus=None
		self.last_focus=None
		self.canvas=None
		self.clips=[]
		self.zoom=100
		self.selstart=(-1,-1)
		self.selend=(-1,-1)
		self.tags=['filename']
		self.copy_tag=[]
		self.mode=None
		self.focus_widget=None
		self.builder = Gtk.Builder()
		for datadir in ['.','/usr/local/share/ctie']:
			fullpath=os.path.join(datadir, 'ctie.xml')
			if os.path.exists(fullpath):
				break
		else:
			sys.stderr.write('Unable to find ctie.xml\n')
			sys.exit(1)

		self.builder.add_from_file(fullpath)
		self.window = self.builder.get_object("main_window")
		self.window.connect("delete-event", Gtk.main_quit)

		level=self.builder.get_object("level")
		level.set_entry_text_column(0)
		level.connect("changed", self.change_level)
		self.level_sanitize()

		#css
		self.css=Gtk.CssProvider()
		self.css.load_from_data("* {background-color: rgba(100,100,255,30);}", -1)

		#keyboard shortcut
		self.window.connect("key-press-event", self.key_press)

		#toolbar
		toolbar=self.builder.get_object('toolbar')

		button=Gtk.Button()
		btn_img=Gtk.Image.new_from_stock(Gtk.STOCK_OPEN, Gtk.IconSize.SMALL_TOOLBAR)
		button.set_image(btn_img)
		button.connect("clicked", self.open_project)
		toolbar.pack_start(button, False, False, 0)

		button=Gtk.Button()
		btn_img=Gtk.Image.new_from_stock(Gtk.STOCK_SAVE, Gtk.IconSize.SMALL_TOOLBAR)
		button.set_image(btn_img)
		button.connect("clicked", self.save_project)
		toolbar.pack_start(button, False, False, 0)

		sep=Gtk.Separator(orientation=Gtk.Orientation.VERTICAL)
		toolbar.pack_start(sep, False, False, 1)

		button=Gtk.Button()
		btn_img=Gtk.Image.new_from_stock(Gtk.STOCK_ADD, Gtk.IconSize.SMALL_TOOLBAR)
		button.set_image(btn_img)
		button.connect("clicked", self.add_item)
		toolbar.pack_start(button, False, False, 0)

		button=Gtk.Button()
		btn_img=Gtk.Image.new_from_stock(Gtk.STOCK_REMOVE, Gtk.IconSize.SMALL_TOOLBAR)
		button.set_image(btn_img)
		button.connect("clicked", self.remove_item)
		toolbar.pack_start(button, False, False, 0)

		sep=Gtk.Separator(orientation=Gtk.Orientation.VERTICAL)
		toolbar.pack_start(sep, False, False, 1)

		button=Gtk.Button()
		btn_img=Gtk.Image.new_from_stock(Gtk.STOCK_ZOOM_IN, Gtk.IconSize.SMALL_TOOLBAR)
		button.set_image(btn_img)
		button.connect("clicked", self.zoom_in)
		toolbar.pack_start(button, False, False, 0)

		button=Gtk.Button()
		btn_img=Gtk.Image.new_from_stock(Gtk.STOCK_ZOOM_OUT, Gtk.IconSize.SMALL_TOOLBAR)
		button.set_image(btn_img)
		button.connect("clicked", self.zoom_out)
		toolbar.pack_start(button, False, False, 0)

		button=Gtk.Button()
		btn_img=Gtk.Image.new_from_stock(Gtk.STOCK_ZOOM_100, Gtk.IconSize.SMALL_TOOLBAR)
		button.set_image(btn_img)
		button.connect("clicked", self.zoom_100)
		toolbar.pack_start(button, False, False, 0)

		button=Gtk.Button()
		btn_img=Gtk.Image.new_from_stock(Gtk.STOCK_ZOOM_FIT, Gtk.IconSize.SMALL_TOOLBAR)
		button.set_image(btn_img)
		button.connect("clicked", self.zoom_fit)
		toolbar.pack_start(button, False, False, 0)

		sep=Gtk.Separator(orientation=Gtk.Orientation.VERTICAL)
		toolbar.pack_start(sep, False, False, 1)

		button=Gtk.Button()
		btn_img=Gtk.Image.new_from_stock(Gtk.STOCK_FIND, Gtk.IconSize.SMALL_TOOLBAR)
		button.set_image(btn_img)
		button.connect("clicked", self.findempty)
		toolbar.pack_start(button, False, False, 0)

		sep=Gtk.Separator(orientation=Gtk.Orientation.VERTICAL)
		toolbar.pack_start(sep, False, False, 1)

		button=Gtk.Button()
		btn_img=Gtk.Image.new_from_stock(Gtk.STOCK_GOTO_FIRST, Gtk.IconSize.SMALL_TOOLBAR)
		button.set_image(btn_img)
		button.connect("clicked", self.ltrim)
		toolbar.pack_start(button, False, False, 0)

		button=Gtk.Button()
		btn_img=Gtk.Image.new_from_stock(Gtk.STOCK_GOTO_LAST, Gtk.IconSize.SMALL_TOOLBAR)
		button.set_image(btn_img)
		button.connect("clicked", self.rtrim)
		toolbar.pack_start(button, False, False, 0)

		sep=Gtk.Separator(orientation=Gtk.Orientation.VERTICAL)
		toolbar.pack_start(sep, False, False, 1)

		button=Gtk.Button()
		btn_img=Gtk.Image.new_from_stock(Gtk.STOCK_COPY, Gtk.IconSize.SMALL_TOOLBAR)
		button.set_image(btn_img)
		button.connect("clicked", self.copy)
		toolbar.pack_start(button, False, False, 0)

		button=Gtk.Button()
		btn_img=Gtk.Image.new_from_stock(Gtk.STOCK_PROPERTIES, Gtk.IconSize.SMALL_TOOLBAR)
		button.set_image(btn_img)
		button.connect("clicked", self.copy_setting)
		toolbar.pack_start(button, False, False, 0)

		button=Gtk.Button()
		btn_img=Gtk.Image.new_from_stock(Gtk.STOCK_PASTE, Gtk.IconSize.SMALL_TOOLBAR)
		button.set_image(btn_img)
		button.connect("clicked", self.paste)
		toolbar.pack_start(button, False, False, 0)

		button=Gtk.Button()
		btn_img=Gtk.Image.new_from_stock(Gtk.STOCK_FIND_AND_REPLACE, Gtk.IconSize.SMALL_TOOLBAR)
		button.set_image(btn_img)
		button.connect("clicked", self.autopaste)
		toolbar.pack_start(button, False, False, 0)

		button=Gtk.Button()
		btn_img=Gtk.Image.new_from_stock(Gtk.STOCK_MEDIA_REWIND, Gtk.IconSize.SMALL_TOOLBAR)
		button.set_image(btn_img)
		button.connect("clicked", self.previous)
		toolbar.pack_start(button, False, False, 0)

		button=Gtk.Button()
		btn_img=Gtk.Image.new_from_stock(Gtk.STOCK_MEDIA_FORWARD, Gtk.IconSize.SMALL_TOOLBAR)
		button.set_image(btn_img)
		button.connect("clicked", self.next)
		toolbar.pack_start(button, False, False, 0)

		button=Gtk.Button()
		btn_img=Gtk.Image.new_from_stock(Gtk.STOCK_DELETE, Gtk.IconSize.SMALL_TOOLBAR)
		button.set_image(btn_img)
		button.connect("clicked", self.delete)
		toolbar.pack_start(button, False, False, 0)

		sep=Gtk.Separator(orientation=Gtk.Orientation.VERTICAL)
		toolbar.pack_start(sep, False, False, 1)

		button=Gtk.Button()
		btn_img=Gtk.Image.new_from_stock(Gtk.STOCK_JUMP_TO, Gtk.IconSize.SMALL_TOOLBAR)
		button.set_image(btn_img)
		button.connect("clicked", self.export_show)
		toolbar.pack_start(button, False, False, 0)

		toolbar.show_all()

		#workarea
		workarea=self.builder.get_object("workarea")
		workarea.connect("button-press-event", self.workarea_mouse)
		workarea.connect("button-release-event", self.workarea_mouse)
		workarea.connect("motion-notify-event", self.workarea_mouse)

		#tag
		self.builder.get_object('btn_add_tag').connect('clicked', self.add_tag)

		#filechooser
		self.builder.get_object('btn_item_add').connect('clicked', self.add_item_cb)
		self.builder.get_object('btn_item_cancel').connect('clicked', self.hide_filechooser)

		#export
		self.builder.get_object('btn_append_tag').connect('clicked', self.append_tag)
		self.builder.get_object('btn_export_close').connect('clicked', lambda x: self.builder.get_object('export_window').hide())
		self.builder.get_object('btn_export').connect('clicked', self.do_export)

		#copy setting
		self.builder.get_object('btn_copy_setting_close').connect('clicked', lambda x: self.builder.get_object('copy_setting_window').hide())

		#launch
		self.window.show()

	def findempty(self, *arg):
		c=self.focus_widget
		while c:
			p=c.get_data("p")
			if not p:
				continue
			if flag and not len(p['children']):
				click(c)
				break
			c=c.get_data("next")

	def previous(self, *arg):
		if not len(self.focus['children']):
			pass
		elif len(self.selections)!=1:
			self.selections=[0]
		else:
			self.selections[0]+=1
			self.selections[0]%=len(self.focus['children'])
		self.canvas.queue_draw()

	def next(self, *arg):
		if not len(self.focus['children']):
			pass
		elif len(self.selections)!=1:
			self.selections=[0]
		else:
			self.selections[0]-=1
			self.selections[0]+=len(self.focus['children'])
			self.selections[0]%=len(self.focus['children'])
		self.canvas.queue_draw()

	def key_press(self, obj, evt):
		if evt.keyval==Gdk.KEY_Page_Down:
			next=self.focus_widget.get_data("next")
			if next:
				click(next)
			return False
		elif evt.keyval==Gdk.KEY_Page_Up:
			prev=self.focus_widget.get_data("prev")
			if prev:
				click(prev)
			return False

	def ltrim(self, *arg):
		if len(self.clips)==0 or not self.builder.get_object("level").get_active_text():
			return
		flag=0
		s=self.clips
		for i in xrange(0,int(self.builder.get_object("level").get_active_text())):
			ns=[]
			for x in s:
				ns.extend(x['children'])
			s=ns
		for p in s:
			x1=p['x1']
			y1=p['y1']
			x2=p['x2']
			y2=p['y2']
			it=Item(p)
			im=it.get_pil_l()

			#x1
			stop=False
			for a in xrange(x1,x2):
				last=im.getpixel((a,y1))
				for i in xrange(y1+1,y2):
					c=im.getpixel((a,i))
					if abs(c-last)>10:
						stop=True
						break
					last=c
				if stop:
					break
			nx1=a

			#y1
			stop=False
			for a in xrange(y1,y2):
				last=im.getpixel((x1,a))
				for i in xrange(x1+1,x2):
					c=im.getpixel((i,a))
					if abs(c-last)>10:
						stop=True
						break
					last=c
				if stop:
					break
			ny1=a

			p['x1']=nx1
			p['y1']=ny1
		self.redraw_items_list()

	def rtrim(self, *arg):
		if len(self.clips)==0 or not self.builder.get_object("level").get_active_text():
			return
		flag=0
		s=self.clips
		for i in xrange(0,int(self.builder.get_object("level").get_active_text())):
			ns=[]
			for x in s:
				ns.extend(x['children'])
			s=ns
		for p in s:
			x1=p['x1']
			y1=p['y1']
			x2=p['x2']
			y2=p['y2']
			it=Item(p)
			im=it.get_pil_l()

			#x2
			stop=False
			for a in xrange(x2-1,x1-1,-1):
				last=im.getpixel((a,y1))
				for i in xrange(y1+1,y2):
					c=im.getpixel((a,i))
					if abs(c-last)>10:
						stop=True
						break
					last=c
				if stop:
					break
			nx2=a

			#y2
			stop=False
			for a in xrange(y2-1,y1-1,-1):
				last=im.getpixel((x1,a))
				for i in xrange(x1+1,x2):
					c=im.getpixel((i,a))
					if abs(c-last)>10:
						stop=True
						break
					last=c
				if stop:
					break
			ny2=a

			p['x2']=nx2
			p['y2']=ny2
		self.redraw_items_list()

	def open_project(self, *arg):
		global id_map, tempdir, clear_tempdir
		filec=Gtk.FileChooserDialog("Open", self.builder.get_object("main_window"), Gtk.FileChooserAction.SAVE, (Gtk.STOCK_CANCEL, Gtk.ResponseType.CANCEL, Gtk.STOCK_OPEN, Gtk.ResponseType.ACCEPT))
		if Gtk.Dialog.run(filec)==Gtk.ResponseType.ACCEPT:
			fp=open(filec.get_filename(),'r')
			data=pickle.load(fp)
			fp.close()
			id_map, self.clips, self.tags, self.copy_tag, tempdir=data
			clear_tempdir=False
		filec.destroy()
		self.level_sanitize()
		self.redraw_items_list()
		self.tags_refresh()

	def save_project(self, *arg):
		global clear_tempdir
		filec=Gtk.FileChooserDialog("Save", self.builder.get_object("main_window"), Gtk.FileChooserAction.SAVE, (Gtk.STOCK_CANCEL, Gtk.ResponseType.CANCEL, Gtk.STOCK_SAVE, Gtk.ResponseType.ACCEPT))
		if Gtk.Dialog.run(filec)==Gtk.ResponseType.ACCEPT:
			data=[id_map, self.clips, self.tags, self.copy_tag, tempdir]
			fp=open(filec.get_filename(),'w')
			pickle.dump(data, fp)
			fp.close()
			clear_tempdir=False
		filec.destroy()

	def copy_setting(self, obj, *arg):
		tagsbox=self.builder.get_object("copy_setting_tags")
		c=tagsbox.get_child()
		if c:
			tagsbox.remove(c)
		tags_table=Gtk.Box(orientation=Gtk.Orientation.VERTICAL)
		tagsbox.add(tags_table)
		for i,tag in enumerate(self.tags):
			if tag=='filename':
				continue
			toggle=Gtk.CheckButton.new_with_label(tag)
			if tag in self.copy_tag:
				toggle.set_active(True)
			else:
				toggle.set_active(False)
			toggle.connect('toggled', self.copy_setting_toggle, tag)
			tags_table.pack_start(toggle,False,False,0)
		self.builder.get_object("copy_setting_window").show_all()

	def copy_setting_toggle(self, obj, tag):
		if obj.get_active():
			if tag not in self.copy_tag:
				self.copy_tag.append(tag)
		else:
			if tag in self.copy_tag:
				self.copy_tag.remove(tag)

	def copy(self, *arg):
		if not self.focus:
			return
		self.clipboard=[]
		for i in self.selections:
			p=self.focus['children'][i]
			tags={}
			for tag in self.copy_tag:
				if tag in p['tags']:
					tags[tag]=p['tags'][tag]
			self.clipboard.append({'x1':p['x1']-self.focus['x1'], 'y1':p['y1']-self.focus['y1'], 'x2':p['x2']-self.focus['x1'] ,'y2':p['y2']-self.focus['y1'] ,'tags':tags})

	def paste(self, *arg):
		if not self.focus:
			return
		self.selections=[]
		cs=[]
		for c in self.focus['children']:
			cs.append((c['x1']-self.focus['x1'], c['y1']-self.focus['y1'], c['x2']-self.focus['x1'], c['y2']-self.focus['y1']))
		for p in self.clipboard:
			path=self.focus['path']
			tags={'filename':os.path.basename(path)}
			for tag in p['tags']:
				tags[tag]=p['tags'][tag]
			x1=p['x1']
			y1=p['y1']
			x2=p['x2']
			y2=p['y2']
			x1=max(x1,0)
			y1=max(y1,0)
			x2=min(x2,self.focus['x2']-self.focus['x1'])
			y2=min(y2,self.focus['y2']-self.focus['y1'])
			if x2-x1>1 and y2-y1>1:
				self.selections.append(len(self.focus['children']))
				if (x1,y1,x2,y2) in cs:
					continue
				self.focus['children'].append({'path':path,'x1':x1+self.focus['x1'],'y1':y1+self.focus['y1'],'x2':x2+self.focus['x1'],'y2':y2+self.focus['y1'],'children':[], 'tags':tags, 'parent':self.focus})
		self.canvas.queue_draw()

	def autopaste(self, *arg):
		if not self.clipboard:
			return
		items_list=self.builder.get_object("items_list")
		cs=items_list.get_children()
		for c in cs:
			p=c.get_data("p")
			if not p:
				continue
			if len(p['children']):
				continue
			im=Image.open(p['path']).convert('L')
			paste=True
			for cp in self.clipboard:
				lastpixel=im.getpixel((p['x1']+cp['x1'],p['y1']+cp['y1']))
				y=p['y1']+cp['y1']
				for x in xrange(p['x1']+cp['x1']+1,p['x1']+cp['x2']-1):
					pixel=im.getpixel((x,y))
					if abs(pixel-lastpixel)>10:
						paste=False
						break
					lastpixel=pixel
				if not paste:
					break
				x=p['x1']+cp['x2']-1
				for y in xrange(p['y1']+cp['y1']+1,p['y1']+cp['y2']-1):
					pixel=im.getpixel((x,y))
					if abs(pixel-lastpixel)>10:
						paste=False
						break
					lastpixel=pixel
				if not paste:
					break
				y=p['y1']+cp['y2']-1
				for x in xrange(p['x1']+cp['x1']+1,p['x1']+cp['x2']):
					pixel=im.getpixel((x,y))
					if abs(pixel-lastpixel)>10:
						paste=False
						break
					lastpixel=pixel
				if not paste:
					break
				x=p['x1']+cp['x1']
				for y in xrange(p['y1']+cp['y1']+1,p['y1']+cp['y2']):
					pixel=im.getpixel((x,y))
					if abs(pixel-lastpixel)>10:
						paste=False
						break
					lastpixel=pixel
			if not paste:
				continue
			del(im)
			for cp in self.clipboard:
				tags={'filename':os.path.basename(p['path'])}
				for tag in cp['tags']:
					tags[tag]=cp['tags'][tag]
				x1=cp['x1']
				y1=cp['y1']
				x2=cp['x2']
				y2=cp['y2']
				x1=max(x1,0)
				y1=max(y1,0)
				x2=min(x2,p['x2']-p['x1'])
				y2=min(y2,p['y2']-p['y1'])
				if x2-x1>1 and y2-y1>1:
					p['children'].append({'path':p['path'],'x1':x1+p['x1'],'y1':y1+p['y1'],'x2':x2+p['x1'],'y2':y2+p['y1'],'children':[], 'tags':tags, 'parent':p})
		self.canvas.queue_draw()

	def delete(self, *arg):
		if not self.focus:
			return
		self.clipboard=[]
		self.selections.sort()
		self.selections.reverse()
		for i in self.selections:
			del(self.focus['children'][i])
		self.selections=[]
		self.canvas.queue_draw()

	def do_export(self, *arg):
		s=self.clips
		while s:
			ns=[]
			for p in s:
				if not p['children']:
					t=p
					tags={}
					while t:
						for tag in t['tags']:
							if tag not in tags:
								tags[tag]=t['tags'][tag]
						t=t['parent']
					for tag in self.tags:
						if tag not in tags:
							tags[tag]=""						

					path=self.builder.get_object('path_pattern').get_text()
					path=path.split("${")
					for i,t in enumerate(path):
						t2=t.split("}",1)
						if t2[0] in tags:
							t2[0]=tags[t2[0]]
						path[i]=''.join(t2)

					path=''.join(path)
					path=os.path.join(self.builder.get_object('output_dir').get_filename(), path)
					pdir=os.path.dirname(path)
					if not os.path.exists(pdir):
						os.makedirs(pdir)		
					im=Image.open(p['path']).convert("RGBA").crop((p['x1'],p['y1'],p['x2'],p['y2']))
					im.save(path)
				ns.extend(p['children'])
			s=ns

	def append_tag(self, *arg):
		b=self.builder.get_object('path_pattern')
		b.set_text("%s${%s}" % (b.get_text(), self.builder.get_object('tags_list').get_active_text()))

	def export_show(self, *arg):
		tags_list=self.builder.get_object('tags_list')
		tags_list.set_entry_text_column(0)
		tags_list.remove_all()
		for tag in self.tags:
			tags_list.append_text(tag)
		self.builder.get_object('export_window').show()

	def add_tag(self, *arg):
		tag=self.builder.get_object('new_tag').get_text()
		if tag and not tag in self.tags:
			self.tags.append(tag)
		self.tags_refresh()

	def canvas_draw(self, widget, cr):
		if not self.focus:
			return
		factor=self.zoom*0.01
		p=self.focus
		width=p['x2']-p['x1']
		height=p['y2']-p['y1']

		cr.scale(factor, factor)
		self.canvas.set_size_request(int(width*factor), int(height*factor))

		Gdk.cairo_set_source_pixbuf(cr, self.current_image.get_pixbuf(), 0, 0)
		cr.paint()
		for i,c in enumerate(p['children']):
			x1=(c['x1']-p['x1'])
			y1=(c['y1']-p['y1'])
			x2=(c['x2']-p['x1'])
			y2=(c['y2']-p['y1'])
			if i in self.selections:
				cr.set_source_rgba(0,0,255,255)
				xoff=self.selend[0]-self.selstart[0]
				yoff=self.selend[1]-self.selstart[1]
				if self.mode=='move':
					cr.rectangle(x1+xoff, y1+yoff, x2-x1, y2-y1)
				elif self.mode=='resize':
					cr.rectangle(x1, y1, x2-x1+xoff, y2-y1+yoff)
				else:
					cr.rectangle(x1, y1, x2-x1, y2-y1)
			else:
				cr.set_source_rgba(255,0,0,255)
				cr.rectangle(x1, y1, x2-x1, y2-y1)
			cr.stroke()
		if self.selstart!=(-1,-1) and len(self.selections)==0:
			cr.set_source_rgba(255,0,255,255)
			cr.rectangle(self.selstart[0], self.selstart[1], self.selend[0]-self.selstart[0], self.selend[1]-self.selstart[1])
			cr.stroke()

	def zoom_fit(self, *arg):
		if not self.focus or not self.canvas:
			return
		p=self.focus
		workarea_window=self.builder.get_object('workarea_window')
		alloc=workarea_window.get_allocation()
		win_width=alloc.width
		win_height=alloc.height
		width=p['x2']-p['x1']
		height=p['y2']-p['y1']
		if width>win_width*0.8:
			self.zoom=(win_width*0.8/width)*100
		else:
			self.zoom=100
		self.canvas.queue_draw()

	def zoom_100(self, *arg):
		if not self.focus or not self.canvas:
			return
		self.zoom=100
		self.canvas.queue_draw()

	def zoom_in(self, *arg):
		if not self.focus or not self.canvas:
			return
		self.zoom+=5
		self.canvas.queue_draw()

	def zoom_out(self, *arg):
		if not self.focus or not self.canvas:
			return
		if self.zoom>5:
			self.zoom-=5
		self.canvas.queue_draw()

	def hide_filechooser(self, *arg):
		self.builder.get_object('filechooserdialog').hide()

	def remove_item(self, *arg):
		if not self.focus_widget:
			return
		items_list=self.builder.get_object("items_list")

		level_change=False
		prev=self.focus_widget.get_data("prev")
		next=self.focus_widget.get_data("next")

		self.focus_widget.set_data("prev", None)
		self.focus_widget.set_data("next", None)
		items_list.remove(self.focus_widget)

		if next:
			new_focus_widget=next
			next.set_data("prev", prev)
			if prev:
				prev.set_data("next", next)
		elif prev:
			new_focus_widget=prev
			prev.set_data("next", next)
			if next:
				next.set_data("prev", prev)
		else:
			level_change=True
			new_focus_widget=None
			self.focus=None
			workarea=self.builder.get_object("workarea")
			c=workarea.get_child()
			if c:
				workarea.remove(c)
				c.destroy()

		if self.focus:
			parent=self.focus['parent']
			if not parent:
				idx=self.clips.index(self.focus)
				del(self.clips[idx])
			else:
				idx=parent['children'].index(self.focus)
				del(parent['children'][idx])

		if new_focus_widget:
			click(new_focus_widget)
		if level_change:
			self.level_sanitize()

	def add_item(self, *arg):
		self.builder.get_object('filechooserdialog').show()

	def add_item_cb(self, *arg):
		cs=self.builder.get_object("filechooserdialog").get_filenames()
		cs.sort(natcmp)
		for path in cs:
			self.add_item_r(path)
		self.hide_filechooser()
		self.level_sanitize()

	def add_item_r(self, path):
		if os.path.isdir(path):
			cs=os.listdir(path)
			cs.sort(natcmp)
			for c in cs:
				self.add_item_r(os.path.join(path,c))
		else:
			try:
				im=Image.open(path)
			except:
				return
			id_map[path]=md5.new(path).hexdigest()
			self.clips.append({'path':path,'x1':0,'y1':0,'x2':im.size[0],'y2':im.size[1],'children':[], 'tags':{'filename':os.path.basename(path)}, 'parent':None})
			del(im)

	def change_level(self, *arg):
		level=self.builder.get_object("level").get_active_text()
		if level!=self.curr_level and level:
			self.focus_field=(None, None)
			self.last_focus=self.focus
			self.last_level=self.curr_level
			self.curr_level=level
			self.focus=None
			self.redraw_items_list()

	def redraw_items_list(self, *arg):
		if len(self.clips)==0 or not self.builder.get_object("level").get_active_text():
			return
		focus_p=None
		if self.focus_widget:
			focus_p=self.focus_widget.get_data("p")
			self.focus_widget.get_style_context().remove_provider(self.css)
			self.focus_widget=None
		items_list=self.builder.get_object("items_list")
		for c in items_list.get_children():
			items_list.remove(c)
			c.destroy()
		flag=0
		s=self.clips
		for i in xrange(0,int(self.builder.get_object("level").get_active_text())):
			ns=[]
			for x in s:
				ns.extend(x['children'])
			s=ns
		last=None
		for p in s:
			it=Item(p)
			tfile=it.get_thumbnail()
			evtbox=Gtk.EventBox()
			box=Gtk.Box(orientation=Gtk.Orientation.VERTICAL)
			img=Gtk.Image.new_from_file(tfile)
			label=Gtk.Label(os.path.basename(p['path']))
			box.pack_start(img, False, False, 0)
			box.pack_start(label, False, False, 0)
			evtbox.add(box)
			if last:
				last.set_data("next", evtbox)
			evtbox.set_data("p", p)
			evtbox.set_data("prev", last)
			evtbox.set_data("next", None)
			last=evtbox
			evtbox.connect("button-press-event", self.item_button_press)
			items_list.pack_start(evtbox, False, False, 5)
			evtbox.show_all()
			if not flag:
				if self.last_level and self.curr_level>self.last_level:
					t=p
					while t and not flag:
						if self.last_focus==t['parent']:
							flag=1
							self.focus_widget=evtbox
							break
						t=t['parent']
				elif self.last_level and self.curr_level<self.last_level:
					s=[]
					s.extend(p['children'])
					while s and not flag:
						ns=[]
						for c in s:
							if self.last_focus==c:
								flag=1
								self.focus_widget=evtbox
								break
							ns.extend(c['children'])
						s=ns
				elif focus_p==p:
					self.focus_widget=evtbox
					flag=1
		if not self.focus_widget:
			cl=items_list.get_children()
			if cl:
				self.focus_widget=cl[-1]

		if self.focus_widget:
			click(self.focus_widget)

	def autoscroll(self):
		items_list=self.builder.get_object("items_list")
		focus_widget=self.focus_widget
		alloc=items_list.get_allocation()
		x,y=focus_widget.translate_coordinates(items_list, 0, 0)
		scr=self.builder.get_object("scroll_items_list")
		vadj=scr.get_vadjustment()
		vadj.set_lower(0)
		vadj.set_upper(alloc.height)
		alloc=scr.get_allocation()
		vadj.set_value(y-alloc.height*0.3)

	def level_sanitize(self):
		level=self.builder.get_object("level")
		l=0
		s=self.clips
		while s:
			l+=1
			ns=[]
			for x in s:
				ns.extend(x['children'])
			s=ns
		try:
			active=int(level.get_active_text())
		except:
			active=0
		level.remove_all()
		for i in xrange(0,l):
			level.append_text(str(i))
		if active<l:
			level.set_active(active)
		else:
			level.set_active(l-1)

	def item_button_press(self, obj, evt):
		if self.focus_widget:
			self.focus_widget.get_style_context().remove_provider(self.css)
		if evt.button==1 and evt.type==Gdk.EventType.BUTTON_PRESS:
			cpath=obj.get_data("p")
			self.focus_widget=obj
			GObject.idle_add(self.autoscroll)
			self.item_select(cpath)

	def tags_refresh(self, *arg):
		if not self.focus:
			return
		self.builder.get_object('tags_pane').show_all()

		tagsbox=self.builder.get_object('tags')
		c=tagsbox.get_child()
		if c:
			tagsbox.remove(c)

		t=self.focus
		tags={}
		while t:
			for tag in t['tags']:
				if tag not in tags:
					tags[tag]=t['tags'][tag]
			t=t['parent']
		for tag in self.tags:
			if tag not in tags:
				tags[tag]=""

		tags_table=Gtk.Grid()
		tagsbox.add(tags_table)
		for i,tag in enumerate(self.tags):
			text=Gtk.Entry()
			text.set_text(tags[tag])
			text.connect('changed', self.set_tag, ('p', self.focus, tag))
			if self.focus_field[0]=='p' and self.focus_field[1]==tag:
				self.focus_entry=text
			label=Gtk.Label(tag)
			button=Gtk.Button()
			btn_img=Gtk.Image.new_from_stock(Gtk.STOCK_CLEAR, Gtk.IconSize.BUTTON)
			button.set_image(btn_img)
			button.connect("clicked", self.clear_tag, (self.focus,tag))
			tags_table.attach(label,0,i,1,1)
			tags_table.attach(text,1,i,1,1)
			tags_table.attach(button,2,i,1,1)
		tagsbox.show_all()
		GObject.idle_add(self.autofocus)
		self.child_tags_refresh()

	def child_tags_refresh(self, *arg):
		if not self.focus:
			return

		tagsbox=self.builder.get_object('child_tags')
		c=tagsbox.get_child()
		if c:
			tagsbox.remove(c)

		if len(self.selections)!=1:
			return

		p=self.focus['children'][self.selections[0]]
		t=p
		tags={}
		while t:
			for tag in t['tags']:
				if tag not in tags:
					tags[tag]=t['tags'][tag]
			t=t['parent']
		for tag in self.tags:
			if tag not in tags:
				tags[tag]=""
		tags_table=Gtk.Grid()
		tagsbox.add(tags_table)
		for i,tag in enumerate(self.tags):
			text=Gtk.Entry()
			text.set_text(tags[tag])
			text.connect('changed', self.set_tag, ('c', p, tag))
			if self.focus_field[0]=='c' and self.focus_field[1]==tag:
				self.focus_entry=text
			label=Gtk.Label(tag)
			button=Gtk.Button()
			btn_img=Gtk.Image.new_from_stock(Gtk.STOCK_CLEAR, Gtk.IconSize.BUTTON)
			button.set_image(btn_img)
			button.connect("clicked", self.clear_tag, (p,tag))
			tags_table.attach(label,0,i,1,1)
			tags_table.attach(text,1,i,1,1)
			tags_table.attach(button,2,i,1,1)
		tagsbox.show_all()
		GObject.idle_add(self.autofocus)

	def autofocus(self, *arg):
		if self.focus_entry:
			if not self.focus_entry.get_text():
				self.focus_entry.paste_clipboard()
				GObject.idle_add(self.autofocus2)		
				self.focus_entry.grab_focus()
			else:
				self.focus_entry.grab_focus()
				self.focus_entry=None

	def autofocus2(self, *arg):
		self.focus_entry.set_position(-1)
		self.focus_entry=None

	def set_tag(self, obj, data):
		t,item,tag=data
		self.focus_field=(t,tag)
		item['tags'][tag]=obj.get_buffer().get_text()

	def clear_tag(self, obj, data):
		del(item['tags'][tag])
		item,tag=data
		self.tags_refresh()

	def item_select(self, p):
		self.focus=p
		id=id_map[p['path']]
		self.selections=[]

		self.tags_refresh()

		it=Item(p)
		self.current_image=it.get_gtk()
		workarea=self.builder.get_object('workarea')
		c=workarea.get_child()
		if c:
			workarea.remove(c)
			c.destroy()
		canvas=Gtk.DrawingArea()
		self.canvas=canvas
		workarea.add(canvas)
		canvas.connect("draw", self.canvas_draw)
		canvas.show()
		self.zoom_fit()
		if self.focus_widget:
			self.focus_widget.get_style_context().add_provider(self.css, 10)

	def workarea_mouse(self, obj, evt):
		if not self.canvas:
			return
		factor=1
		factor=self.zoom*0.01
		x=evt.x/factor
		y=evt.y/factor
		p=self.focus
		if str(type(evt))==repr(Gdk.EventButton):
			if evt.button==1 and evt.type==Gdk.EventType.BUTTON_PRESS:
				self.selstart=(x,y)
				if not len(self.selections):
					self.mode='rectangle'
				else:
					for i in self.selections:
						c=self.focus['children'][i]
						if x+p['x1']>c['x1'] and x+p['x1']<c['x2'] and y+p['y1']>c['y1'] and y+p['y1']<c['y2']:
							self.mode='move'
							break
					else:
						self.mode='resize'
			elif evt.button==1 and evt.type==Gdk.EventType.BUTTON_RELEASE:
				x1,y1=self.selstart
				if x1<0 or y1<0:
					return
				if x1==x and y1==y:
					for i,c in enumerate(p['children']):
						if x+p['x1']>c['x1'] and x+p['x1']<c['x2'] and y+p['y1']>c['y1'] and y+p['y1']<c['y2']:
							if i in self.selections:
								self.selections.remove(i)
							else:
								self.selections.append(i)
						self.child_tags_refresh()
				elif self.mode=='rectangle':
					if x1>x:
						x1,x=x,x1
					if y1>y:
						y1,y=y,y1
					x1=max(x1,0)
					y1=max(y1,0)
					x=min(x,p['x2']-p['x1'])
					y=min(y,p['y2']-p['y1'])
					if x-x1>5 and y-y1>5:
						p['children'].append({'path':p['path'], 'x1':int(x1+p['x1']), 'y1':int(y1+p['y1']), 'x2':int(x+p['x1']), 'y2':int(y+p['y1']), 'children':[], 'parent':p, 'tags':{'filename':os.path.basename(p['path'])}})
					self.level_sanitize()
				elif self.mode=='move':
					xoff=int(self.selend[0]-self.selstart[0])
					yoff=int(self.selend[1]-self.selstart[1])
					todo=[]
					for i in self.selections:
						todo.append(p['children'][i])
					delete=[]
					while todo:
						newtodo=[]
						for c in todo:
							x1=c['x1']-p['x1']+int(xoff)
							y1=c['y1']-p['y1']+int(yoff)
							x=c['x2']-p['x1']+int(xoff)
							y=c['y2']-p['y1']+int(yoff)
							x1=max(x1,0)
							y1=max(y1,0)
							x=min(x,p['x2']-p['x1'])
							y=min(y,p['y2']-p['y1'])
							x1=min(x1,p['x2']-p['x1'])
							y1=min(y1,p['y2']-p['y1'])
							x=max(x,0)
							y=max(y,0)
							c['x1']=x1+p['x1']
							c['y1']=y1+p['y1']
							c['x2']=x+p['x1']
							c['y2']=y+p['y1']
						if abs(x-x1)<=1 or abs(y-y1)<=1:
							delete.append(c)
						else:
							newtodo.extend(c['children'])
						todo=newtodo
					for c in delete:
						if c['parent']:
							c['parent']['children'].remove(c)
					self.level_sanitize()
				elif self.mode=='resize':
					xoff=int(self.selend[0]-self.selstart[0])
					yoff=int(self.selend[1]-self.selstart[1])
					for i in self.selections:
						c=self.focus['children'][i]
						x1=c['x1']-p['x1']
						y1=c['y1']-p['y1']
						x=c['x2']-p['x1']+xoff
						y=c['y2']-p['y1']+yoff
						if x1>x:
							x1,x=x,x1
						if y1>y:
							y1,y=y,y1
						if x1<0:
							x1=0
						if y1<0:
							y1=0
						if x>p['x2']-p['x1']:
							x=p['x2']-p['x1']
						if y>p['y2']-p['y1']:
							y=p['y2']-p['y1']
						c['x1']=x1+p['x1']
						c['y1']=y1+p['y1']
						c['x2']=x+p['x1']
						c['y2']=y+p['y1']
				self.selstart=(-1,-1)
				self.selend=(-1,-1)
				self.mode=None
				self.canvas.queue_draw()
			elif evt.button==3:
				self.selstart=(-1,-1)
		elif str(type(evt))==repr(Gdk.EventMotion):
			self.selend=(x,y)
			self.canvas.queue_draw()

if __name__ == "__main__":
	app = CTIE()
	Gtk.main()
	if clear_tempdir:
		os.execvp("rm",["rm","-rf",tempdir])
